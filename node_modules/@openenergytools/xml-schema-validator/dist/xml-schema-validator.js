function isValidationResult(msg) {
    return (typeof msg !== "string" &&
        msg.file !== undefined &&
        msg.valid !== undefined &&
        msg.loaded === undefined);
}
function isValidationError(msg) {
    return (typeof msg !== "string" &&
        msg.file !== undefined &&
        msg.valid === undefined &&
        msg.loaded === undefined);
}
function isLoadSchemaResult(msg) {
    return (typeof msg !== "string" &&
        msg.file !== undefined &&
        msg.valid === undefined &&
        msg.loaded !== undefined);
}
const validators = {};
async function validate(xml, xsd) {
    const issues = [];
    async function getValidator(xsd, xsdName) {
        // Catch browsers not supporting workers
        if (!window.Worker)
            throw new Error("Invalid schema");
        // Avoid init same XSD multiple times
        if (validators[xsdName])
            return validators[xsdName];
        const worker = new Worker(new URL("./xmlvalidate/worker.js", import.meta.url));
        async function validate(xml, xmlName, results) {
            return new Promise((resolve) => {
                worker.addEventListener("message", (e) => {
                    if (isValidationResult(e.data) && e.data.file === xmlName) {
                        resolve(e.data);
                    }
                    else if (isValidationError(e.data)) {
                        const parts = e.data.message.split(": ", 2);
                        const description = parts[1] ? parts[1] : parts[0];
                        const qualifiedTag = parts[1] ? ` (${parts[0]})` : "";
                        results.push({
                            title: description,
                            message: `${e.data.file}:${e.data.line} ${e.data.node} ${e.data.part}${qualifiedTag}`,
                        });
                    }
                });
                worker.postMessage({ content: xml, name: xmlName });
            });
        }
        validators[xsdName] = validate;
        return new Promise((resolve, reject) => {
            worker.addEventListener("message", (e) => {
                if (isLoadSchemaResult(e.data)) {
                    if (e.data.loaded)
                        resolve(validate);
                    else
                        reject("Schema cannot be loaded");
                }
            });
            worker.postMessage({ content: xsd, name: xsdName });
        });
    }
    try {
        const validate = await getValidator(xsd.content, xsd.name);
        const result = await validate(xml.content, xml.name, issues);
        if (result.valid)
            issues.push({ title: "Project is schema valid" });
    }
    catch {
        return null;
    }
    return issues;
}

export { isLoadSchemaResult, isValidationError, validate };
//# sourceMappingURL=xml-schema-validator.js.map
