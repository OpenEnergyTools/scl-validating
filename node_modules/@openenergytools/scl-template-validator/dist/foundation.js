import { dAValidator } from './validators/daBda.js';
import { dATypeValidator } from './validators/daType.js';
import { dOValidator } from './validators/doSdo.js';
import { dOTypeValidator } from './validators/doType.js';
import { lNodeTypeValidator } from './validators/lNodeType.js';

const iec6185074 = fetch(new URL("./nsd/IEC_61850-7-4_2007B3.nsd", import.meta.url))
    .then((response) => response.text())
    .then((str) => new DOMParser().parseFromString(str, "application/xml"));
const iec6185073 = fetch(new URL("./nsd/IEC_61850-7-3_2007B3.nsd", import.meta.url))
    .then((response) => response.text())
    .then((str) => new DOMParser().parseFromString(str, "application/xml"));
fetch(new URL("./nsd/IEC_61850-7-2_2007B3.nsd", import.meta.url))
    .then((response) => response.text())
    .then((str) => new DOMParser().parseFromString(str, "application/xml"));
const iec6185081 = fetch(new URL("./nsd/IEC_61850-8-1_2003A2.nsd", import.meta.url))
    .then((response) => response.text())
    .then((str) => new DOMParser().parseFromString(str, "application/xml"));
function isTypeMissing(element) {
    const { tagName } = element;
    const isTypeMandatory = tagName === "DO" ||
        tagName === "SDO" ||
        ((tagName === "DA" || tagName === "BDA") &&
            (element.getAttribute("bType") === "Enum" ||
                element.getAttribute("bType") === "Struct"));
    const isTypeMissing = !element.getAttribute("type");
    return isTypeMandatory && isTypeMissing;
}
function getTypeChild(element) {
    const isStruct = element.getAttribute("bType") === "Struct";
    const isEnum = element.getAttribute("bType") === "Enum";
    const isDo = element.tagName === "DO" || element.tagName === "SDO";
    const referenceTag = isDo
        ? "DOType"
        : isStruct || isEnum
            ? isStruct
                ? "DAType"
                : "EnumType"
            : null;
    if (!referenceTag)
        return undefined;
    return (element
        .closest("DataTypeTemplates")
        ?.querySelector(`${referenceTag}[id="${element.getAttribute("type")}"]`) ?? null);
}
function getAdjacentClass(nsd, base) {
    if (base === "")
        return [];
    const adjacents = getAdjacentClass(nsd, nsd
        .querySelector(`LNClass[name="${base}"], AbstractLNClass[name="${base}"]`)
        ?.getAttribute("base") ?? "");
    return Array.from(nsd.querySelectorAll(`LNClass[name="${base}"], AbstractLNClass[name="${base}"]`)).concat(adjacents);
}
async function validateChildren(element) {
    const issues = [];
    const children = Array.from(element.children);
    for (const child of children) {
        const validator = tagValidator[child.tagName];
        if (!validator)
            continue;
        const childIssues = await validator(child);
        if (childIssues.length)
            for (const childIssue of childIssues)
                issues.push(childIssue);
    }
    return issues;
}
const tagValidator = {
    LNodeType: lNodeTypeValidator,
    DOType: dOTypeValidator,
    DAType: dATypeValidator,
    DO: dOValidator,
    SDO: dOValidator,
    DA: dAValidator,
    BDA: dAValidator,
};

export { getAdjacentClass, getTypeChild, iec6185073, iec6185074, iec6185081, isTypeMissing, tagValidator, validateChildren };
//# sourceMappingURL=foundation.js.map
